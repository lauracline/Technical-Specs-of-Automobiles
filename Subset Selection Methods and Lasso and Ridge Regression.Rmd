---
title: "Subset Selection Methods and Ridge Regression & Lasso"
author: "Laura Cline"
date: "29/09/2021"
output:
  html_document:
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Subset Selection Methods 

## Best Subset Selection 

Here we apply the best subset selection approach to the `Hitters` data. We wish to predict a baseball player's `Salary` on the basis of various statistics associated with performance in the previous year. 

First of all, we note that the `Salary` variable is missing for some of the players. The `is.na()` function can be used to identify missing observations. It returnsa vector of the same length as the input vector, with a `True` for any elements that are missing, and a `False` for non-missing elements. The `sum()` function can then be used to count all the missing elements. 

```{r}
library(ISLR)
names(Hitters)
```
```{r}
dim(Hitters)
```
```{r}
sum(is.na(Hitters$Salary))
```

Hence, we see that `Salary` is missing for 59 players. The `na.omit()` function removes all the rows that have missing values in any variable. 

```{r}
Hitters = na.omit(Hitters)
dim(Hitters)
```
```{r}
sum(is.na(Hitters))
```

The `regsubsets()`function (part of the `leaps` library) performs best subset selection by identifying the best model that contains a given number of predictors, where *best* is quantified using RSS. The syntax is the same as for `lm()`. The `summary()` command outputs the best set of variables for each model size. 

```{r}
#install.packages("leaps")
library(leaps)
```
```{r}
regfit.full = regsubsets(Salary ~., Hitters)
summary(regfit.full)
```

An asterisk indicates that a given variable is include in the corresponding model. For instance, this output indicates that the best two-variable model contains only `Hits` and `CRBI`. By default, `regsubsets()` only reports results up to the best eight-variable model. But the `nvmax` option can be used in order to return as manay variables as are desired. Here we fit up to a 19-variable model. 

```{r}
regfit.full = regsubsets(Salary~., data=Hitters, nvmax=19)
reg.summary = summary(regfit.full)
```

The `summary()` function also returns R^2, RSS, and adjusted R^2, $C_{p}$, and BIC. We can examine these to try to select the *best* overall model. 

```{r}
names(reg.summary)
```

For instance, we see that the R^2 statistic increases from 32% when only one variable is included in the model to almost 55% when all variables are included. As expected, the R^2 statistic increases monotonically as more variables are included. 

```{r}
reg.summary$rsq
```

Plotting RSS, adjusted R^2, $C_{p}$, and BIC for all the models at once will help us decide which model to select. Note the `type="l"` option tells `R` to connect the plotted points with lines. 

```{r}
par(mfrow = c(2,2))
plot(reg.summary$rss, xlab = "Number of Variables", ylab = "RSS", type = "l")
```
```{r}
plot(reg.summary$adjr2, xlab = "Number of Variables", ylab = "Adjusted Rsq", type = "l")
points(11,reg.summary$adjr2[11], col="red", cex=2,pch=20)
```

The `points()` command works like the `plot()` command, except that it puts points on a plot that has already been created, instead of creasing a new plot. The `which.max()` function can be used to identify the location of the maximum point of a vector. We will now plot a red dot to indicate the model with the largest adjusted R^2 statistic.

```{r}
which.max(reg.summary$adjr2)
```

In a similar fashion, we can plot $C_{p}$ and BIC statistics, and indicate the models with the smallest statistic using `which.min()`. 

```{r}
plot(reg.summary$cp, xlab="Number of Variables", ylab = "Cp", type = "l")
points(10, reg.summary$cp[10], col="red", cex=2, pch=20)
which.min(reg.summary$cp)
```
```{r}
#points(10, reg.summary$cp[10], col="red", cex=2, pch=20)
which.min(reg.summary$bic)
```
```{r}
plot(reg.summary$bic, xlab="Number of Variables", ylab="BIC", type="l")
points(6, reg.summary$bic[6], col='red', cex=2, pch=20)
```

The `regsubsets()` function has a built-in `plot()` command which can be used to display the selected variables for the best model with a given number of predictors, ranked according to the BIC, $C_{p]$, adjusted R^2, or AIC. To find out out more about this function, type `?plot.regsubsets`. 

```{r}
plot(regfit.full, scale="r2")
plot(regfit.full, scale = "adjr2")
plot(regfit.full, scale= "Cp")
plot(regfit.full, scale = "bic")
```

The top row of each plot contains a black square for each variable selected according to the optimal model associated with that statistic. For instance, we see that sevrral models share a BIC close to -150. However, the model with the lowest BIC is the six-variable model that contains only `AtBat`, `Hits`, `Walks`, `CRBI`, `DivisionW` and `PutOuts`. We can use the `coef()` function to see the coefficient estimates associated with this model. 

```{r}
coef(regfit.full, 6)
```

## Forward and Backward Stepwise Selection 

We can also use the `regsubsets()` function to perform forward stepwise or backward stepwise selection, using the argument `method="forward"` or `method="backward"`. 

```{r}
regfit.fwd = regsubsets(Salary~., data=Hitters, nvmax=19, method="forward")
summary(regfit.fwd)
```
```{r}
regfit.bwd = regsubsets(Salary~., data=Hitters, nvmax=19, method="backward")
summary(regfit.bwd)
```

For instance, we see that using forward stepwise selection, the best one-variable model contains only `CRBI`, and the best two-variable model additionally includes `Hits`. For this data, the best one-variable through six-variable models are each identical for best subset and forward selection. However, the best seven-variable models identified by forward stepwise selection, backward stepwise selection, and best subset selection are different. 

```{r}
coef(regfit.full, 7)
```
```{r}
coef(regfit.fwd,7)
```
```{r}
coef(regfit.bwd,7)
```

## Choosing Among Models Using the validation Set Approach and Cross-Validation 

We just saw that it is possible to choose among a set of models of different sizes using $C_{p}$, BIC, and adjusted R^2. We will now consider how to do this using the validation set and cross-validation approaches. 

In order for these approaches to yield accurate estimates of the test error, we must use *only the training observations* to perform all aspects of model-fitting - including variable selection. Therefore, the determination of which model of a given size is best must be made using *only the training observations*. This point is subtle but important. If the full dataset is used to perform the best subset selection step, the validation set errors and cross-validation errors that we obtain will not be accurate estimates of the test error. 

In order to use the validation set approach, we begin by splitting the observations into a training set and testing set. We do this by creating a random vector, `train`, of elements equal to `True` if the corresponding observation is in the training set, and `False` otherwise. The vector `test` has a `True` if the observation is in the test set, and `False` otherwise. Note that `!` in the command to create `test` causes `True`s to be switched to `False`s and vice versa. We can also set a random seed so that the user will obtain the same training set/test set split. 

```{r}
set.seed(1)
train = sample(c(TRUE, FALSE), nrow(Hitters), rep=TRUE)
test = (!train)
```

Now, we apply 'regsubsets()' to the training set in order to perform best subset selection. 

```{r}
regfit.best = regsubsets(Salary ~., data=Hitters[train,], nvmax = 19)
```

Notice that we subset the `Hitters` data frame directly in the call in order to access only the training subset of the data, using the expression `Hitters[train,]`. We now compute the validation set error for the best model of each model size. We first make a model matrix from the test data. 

```{r}
test.mat = model.matrix(Salary ~., data=Hitters[test,])
```

The `model.matrix()` function is used in many regression packages for building an "X" matrix from data. Now we run a loop, and for each size `i`, we extract the coefficients from `regfit.best` for the best model of the size, multiply them into the appropriate columns of the test model matrix to form the predictions, and compute the test MSE. 

```{r}
val.errors = rep(NA, 19)
for (i in 1:19) {
  coefi = coef(regfit.best, id=i)
  pred = test.mat[,names(coefi)]%*%coefi
  val.errors[i] = mean((Hitters$Salary[test]-pred)^2)
  }
```

We find that the best model is the one that contains seven variables. 

```{r}
val.errors
```
```{r}
which.min(val.errors)
```
```{r}
coef(regfit.best, 7)
```

This was a little tedious, partly because there is no `predict()` method for `regsubsets()`. Since we will be using this function again, we can capture our steps above and write our own predict method. 

```{r}
predict.regsubsets = function(object, newdata, id,...){
  form = as.formula(object$call[[2]])
  mat = model.matrix(form, newdata)
  coefi = coef(object, id=id)
  xvars = names(coefi)
  mat[,xvars]%*%coefi
}
```

Our function pretty much mimics what we did above. The only complex part is how we extracted the formula used in the call to `regsubsets()`. We demonstrate how we use this function below, when we do cross-validation. 

Finally, we perform best subset selection on the full dataset, and select the best ten-variable model. It is important that we make use of the full dataset in order to obtain more accurate coefficient estimates. Note that we perform best subset selection on the full dataset and select the best ten-variable model, rather than simply using the variables that were obtained from the training set, because the best ten-variable model on the full dataset differ from the corresponding model on the training set. 

```{r}
regfit.best = regsubsets(Salary ~., data=Hitters, nvmax=19)
coef(regfit.best, 10)
```

In fact, we can see that the best ten-variable model on the full dataset has a different set of variables than the best ten-variable model on the training set. 

We now try to choose among the models of different sizes using cross-validation. This approach is somewhat involved, as we must perform best subset selection *within each of the k training sets*. Despite this, we see that with its clever  subsetting syntax, `R` makes the job quite easy. First, we create a vector that allocates each observation to one of k = 10 folds, and we create a matrix in which we will store the results. 

```{r}
k = 10
set.seed(1)
folds = sample(1:k, nrow(Hitters), replace=TRUE)
cv.errors = matrix(NA,k,19, dimnames = list(NULL, paste(1:19)))
```

Now we create a for loop that performs cross-validation. In the jth fold, the elements of `folds` that equal `j` are in the test set, and the remainder are in the training set. We make our predictions for each model size (using our new `predict()` method), compute the test errors on the appropriate subset, and store them in the appropriate slot in the matrix `cv.errors`. 

```{r}
for (j in 1:k){
  best.fit = regsubsets(Salary~., data=Hitters[folds!=j,], nvmax=19)
  for (i in 1:19){
    pred = predict(best.fit, Hitters[folds==j,], id=i)
    cv.errors[j,i] = mean((Hitters$Salary[folds==j]-pred)^2)
  }
}
```

This has given us a 10x19 matrix, of which the (i,j)th element corresponds to the test MSE for the ith cross-validation fold for the best j-variable model. We use the `apply()` function to average over the columns of this matrix in order to obtain a vector for which the jth element is the cross-validation error for the j-variable model. 

```{r}
mean.cv.errors = apply(cv.errors, 2, mean)
mean.cv.errors
```
```{r}
par(mfrow=c(1,1))
plot(mean.cv.errors, type='b')
```

We see that cross-validation selects an 11-variable model. We now perform best subset selection on the full dataset in order to obtain the 11-variable model. 

```{r}
reg.best = regsubsets(Salary ~., data=Hitters, nvmax=19)
coef(reg.best, 11)
```

# Ridge Regression and the Lasso

We will now use the `glmnet` package in order to perform ridge regression and the lasso. The main function in this package is `glmnet()`, which can be used to fit ridge regression models, lasso models and more. This function has slightly different syntax from other model fitting functions that we have encountered thus far in this book. In particular, we must pass in an `x` matrix as well as a `y` vector, and we do not use the `y ~ x` syntax. We will now perform ridge regression and the lasso in order to predict `Salary` on the `Hitters` data. Before proceeding ensure that the missing values have been removed from the data. 

```{r}
x = model.matrix(Salary ~., Hitters)[,-1]
y = Hitters$Salary
```

The `model.matrix()` function is particularly useful for creating `x`; not only does it produce a matrix corresponding to the 19 predictors but it also automatically transforms any qualitative variables into dummy variables. The latter property is important because `glmnet()` can only take numerical quanitative inputs. 

## Ridge Regression 

The `glmnet()` function has an `alpha` argument that determines what type of model is fit. If `alpha=0` then a ridge regression model is fit, and if `alpha=1` then a lasso model is fit. We first fit a ridge regression model. 

```{r}
#install.packages("glmnet")
library(glmnet)
grid = 10^seq(10, -2, length=100)
ridge.mod = glmnet(x, y, alpha=0, lambda=grid)
```

By default the `glmnet()` function performs ridge regression for an automatically selected range of $\lambda$ values. However, here we have chosen to implement the function over a grid of values ranging from $\lambda = 10^{10}$ to $\lambda = 10^{-2}$, essentially covering the full range of scenarios from the null model containing only the intercept, to the least squares fit. As we will see, we can also compute model fits for a particular value of $\lambda$ that is not one of the original $grid$ values. Note that by default, the `glmnet()` function standardizes the variables so that they are on the same scale. To turn off this default setting, use the argument `standardize=False`. 

Associated with each value of $\lambda$ is a vector of ridge regression coefficients stored in a matrix that can be accessed by `coef()`. In this case, it is a 20x100 matrix, with 20 rows (one for each predictor, plus an intercept) and 100 columns (one for each value of $\lambda$). 

```{r}
dim(coef(ridge.mod))
```

We expect the coefficient estimates to be much smaller, in terms of $\ell_{2}$ norm, which a large value of $\lambda$ is used, as compared to when a small value of $\lambda$ is used. There are the coefficients when $\lambda = 11,498$ along with their $\ell_{2}$ norm. 

```{r}
ridge.mod$lambda[50]
```
```{r}
coef(ridge.mod)[,50]
```
```{r}
sqrt(sum(coef(ridge.mod)[-1,50]^2))
```

In contrast, here are the coefficients when $\lambda = 705$, along with their $\ell_{2}$ norm. Note that a much larger $\ell_{2}$ norm of the coefficients associated with this smaller value of $\lambda$. 

```{r}
ridge.mod$lambda[60]
```
```{r}
coef(ridge.mod)[,60]
```
```{r}
sqrt(sum(coef(ridge.mod)[-1,60]^2))
```

We can use the `predict()` function for a number of purposes. For instance, we can obtain the ridge regression coefficients for a new value of $\lambda$, say 50:

```{r}
predict(ridge.mod, s=50, type="coefficients")[1:20,]
```

We now split the samples into a training set and test set in order to estimate the test error of ridge regression and the lasso. There are two common ways to randomly split a dataset. The first is to produce a random vector of `TRUE`, `FALSE` elements and select the observations corresponding to `TRUE` for the training data. The second is to randomly choose a subset of numbers between 1 and *n*; these can then be used as the indices for the training observations. The two approaches work equally well. We will use the latter approach below. 

We first set a random seed so that results obtained will be reproducible. 

```{r}
set.seed(1)
train = sample(1:nrow(x), nrow(x)/2)
test = (-train)
y.test = y[test]
```

Next we fit a ridge regression model on the training set, and evaluate its MSE on the test set, using $\lambda = 4$. Note the use of the `predict()` function again. This time we get predictions for a test set, by replacing `type="coefficients"` with the `newx` argument. 

```{r}
ridge.mod = glmnet(x[train,], y[train], alpha=0, lambda=grid, thresh=1e-12)
ridge.pred = predict(ridge.mod, s=4, newx=x[test,])
mean((ridge.pred - y.test)^2)
```

The test MSE is 142,199. Note that if we had instead simply fit a model with just an intercept, we would have predicted each test observation using the mean of the training observations. In that case, we would compute the test MSE like this. 

```{r}
mean((mean(y[train])-y.test)^2)
```

We could also get the same result by fitting a ridge regression model with a *very* large value of $\lambda$. Note that `1e10` means $10^{10}$. 

```{r}
ridge.pred = predict(ridge.mod, s=1e10, newx=x[test,])
mean((ridge.pred - y.test)^2)
```

So fitting a ridge regression model with $\lambda = 4$ leads to a much lower test MSE than fitting a model with just an intercept. We now check whether there is any benefit to performing ridge regression with $\lambda = 4$ instead of just performing least squares regression. Recall that least squares is simply ridge regression with $\lambda = 0$. 

In order for `glmnet()` to yield the exact least squares coefficients when $lambda = 0$, we use the argument `exact = T` when calling the `predict()` function. Otherwise, the `predict()` function will interpolate over the grid of $\lambda$ values used in fitting the  `glmnet()` model, yielding approximate results. When we use `exact = T`, there remains a slighy discrepancy in the third decimal place between the output of `glmnet()` when $\lambda = 0$ and the output of `lm()`; this is due to numerical approximation on the part of `glmnet()`. 

```{r}
#ridge.pred = predict(ridge.mod, s=0, newx=x[test,], exact=T)
#mean((ridge.pred-y.test)^2)

lm(y~x, subset=train)
#predict(ridge.mod, s=0, exact=T, type="coefficients")[1:20,]
```

In general, if we want to fit a (unpenalized) least squares model, then we should use the `lm()` function, since that function provides more useful outputs, such as standard errors and p-values for the coefficients. 

In general, instead of arbitrary choosing $\lambda = 4$, it would be better to use cross-validation to choose the tuning parameter $\lambda$. We can do this using the built-in cross-validation function; `cv.glmnet()`. By default, the function performs ten-fold cross-validation, though this can be changed using the argument `nfolds`. Note that we set a random seed first so our results will be reproducible, since the choice of the cross-validation folds is random. 

```{r}
set.seed(1)
cv.out = cv.glmnet(x[train,], y[train], alpha=0)
plot(cv.out)
bestlam = cv.out$lambda.min
bestlam
```

Therefore, we see that the value of $\lambda$ that results in the smallest cross-validation error is 326. What is the test MSE associated with this value of $\lambda$?

```{r}
ridge.pred = predict(ridge.mod, s=bestlam, newx = x[test,])
mean((ridge.pred-y.test)^2)
```

This represents a further improvement over the test MSE that we got using $\lambda = 4$. Finally, we refit our ridge regression model on the full dataset, using the value of $\lambda$ chosen by cross-valudation and examine the coefficient estimates. 

```{r}
out = glmnet(x, y, alpha=0)
predict(out, type="coefficients", s=bestlam)[1:20,]
```

As expected, none of the coefficients are zero - ridge regression does not perform variable selection! 

## The Lasso 

We saw that ridge regression with a wise choice of $\lambda$ can outperform least squares as well as the null model on the `Hitters` dataset. We now ask whether the lasso can yield a more accurate or more interpretable model than ridge regression. In order to fit a lasso model, we once again use the `glmnet()` function; however, this time we use the argument `alpha=1`. Other than that change, we proceed just as we did in fitting a ridge model. 

```{r}
lasso.mod = glmnet(x[train,], y[train], alpha = 1, lambda = grid)
plot(lasso.mod)
```

We can see from the coefficient plot that depeneding on the choice of tuning parameter, some of the coefficients will be exactly zero. We now perform cross-validattion and compute the associated test error. 

```{r}
set.seed(1)
cv.out = cv.glmnet(x[train,], y[train], alpha=1)
plot(cv.out)
```
```{r}
bestlam = cv.out$lambda.min
lasso.pred = predict(lasso.mod, s=bestlam, newx=x[test,])
mean((lasso.pred-y.test)^2)
```

This is substantially lower than the test set MSE of the null model and of least squares, and very similiar to the test MSE of ridge regression with $\lambda$ chosen by cross-validation. 

However, the lasso has a substantial advantage over ridge regression in that the resulting coefficient estimates are sparse. Here we see that 12 of the 19 coefficient estimates are exactly zero. So the lasso model with $\lambda$ chosen by cross-validation contains only seven variables. 

```{r}
out = glmnet(x, y, alpha=1, lambda=grid)
lasso.coef = predict(out, type="coefficients", s=bestlam)[1:20,]
lasso.coef
```

# PCR and PLS Regression 

## Principal Components Regression 

Principal components regression (PCR) can be performed using the `pcr()` function, which is part of the `pls` library. We now apply PCR to the `Hitters` data, in order to predict `Salary`. Again, ensure that the missing values have been removed. 

```{r}
library(pls)
set.seed(2)
pcr.fit = pcr(Salary~., data=Hitters, scale=TRUE, validation="CV")
```

The syntax for the `pcr()` function is similiar to that for `lm()`, with a few additional options. Setting `scale=TRUE` has the effect of *standardizing* each predicting prior to generating the principal components, so that the scale on which each variable is measured will not have an effect. Setting `validation="CV"` causes `pcr()` to compute the ten-fold cross-validation error for each possible value of *M*, the number of principal components used. The resulting fit can be examined using `summary()`. 

```{r}
summary(pcr.fit)
```

The CV score is provided for each possible number of components, ranging from M = 0 onwards. Note that `pcr()` reports the *root mean squared error*; in order to obtain the usual MSE, we must square the quantity. For instance, a root mean squared error of 252.8 corresponds to an MSE of $352.8^{2} = 124,468$.

One can also plot the cross-validation scores using the `validationplot()` function. Using `val.type="MSEP"` will cause the cross-validation MSE to be plotted. 

```{r}
validationplot(pcr.fit, val.type="MSEP")
```

We see that the smallest cross-validation errors occurs when M = 16 components are used. This is barely fewer than M = 19, which amounts to simply performing least squares, because when all of the components are used in PCR no dimension reduction occurs. However, from the plot we also see that the cross-validation error is roughly the same when only one component is used in the model. This suggests that a model that uses just a small number of components might suffice. 

The `summary()` function also provides the *percentage of variance explained* in the predictors and in the response using different numbers of components. Briefly, we can think of this as the amount of information about the predictors or the response that is captured using *M* principal components. For example, setting M = 1 only captures 38.31% of all the variance, or information, in the predictors. In conrast, using M = 6, increases the value of 88.63%. If we were to use all M = p = 19 components, this would increase to 1005. 

We now perform PCR on the training data and evaluate its test set performance. 

```{r}
set.seed(1)
pcr.fit = pcr(Salary~., data=Hitters, subset=train, scale=TRUE, validation = "CV")
validationplot(pcr.fit, val.type="MSEP")
```

Now we find the lowest cross-validation error occurs when M = 7 components are usedd. We compute the test MSE as follows. 

```{r}
pcr.pred = predict(pcr.fit, x[test,], ncomp=7)
mean((pcr.pred-y.test)^2)
```

The test set MSE is competitive with the results obtained using ridge regression and the lasso. However, as a result of the way PCR is implemented, the final model is more difficult to interpret because it does not perform any kind of variable selection or even directly produce coefficient estimates. 

Finally, we fit PCR on the full dataset, using M = 7, the number of components identified by cross-validation. 

```{r}
pcr.fit = pcr(y~x, scale=TRUE, ncomp=7)
summary(pcr.fit)
```

## Partial Least Squares

We implement partial least squares (PLS) using the `plsr()` function, also in the `pls` library. The syntax is just like that of the `pcr()` function. 

```{r}
set.seed(1)
pls.fit = plsr(Salary~., data=Hitters, subset=train, scale=TRUE, validation="CV")
summary(pls.fit)
```

The lowest cross-validation error occurs when only M = 2 partial least squares directions are used. We now evaluate the corresponding test set MSE. 

```{r}
pls.pred = predict(pls.fit, x[test,], ncomp=2)
mean((pls.pred-y.test)^2)
```

The test MSE is comparable to, but slightly higher than, the test MSE obtained using ridge regression, the lasso and PCR. 

Finally, we perform PLS using the full dataset, using M=2, the number of components identified by cross-validation. 

```{r}
pls.fit = plsr(Salary~., data=Hitters, scale=TRUE, ncomp=2)
summary(pls.fit)
```

Note that the percentage of variance in `Salary` that the two-component PLS fit explains, 46.40% is almost as much as that explained using the final seven-component model PCR fit, 46.69%. This is because PCR only attempts to maximize the amount of variance explained in the predictors, while PLS searches for directions that explain variance in both the predictors and the response. 

# Excercises 
## Question Eight 

In this excercise, we will generate simulated data, and will then use this data to perform best subset selection. 

A. Use the `rnorm()` function to generate a predictor X of length n = 100, as well as a noise vector $\epsilon$ of length n = 100. 

```{r}
set.seed(0)

n = 100
X = rnorm(n)
epsilon = 0.1 * rnorm(n)
```

B. Generate a response vector Y of length n = 100 according to the model:

$Y = \beta_{0} + \beta_{1}X + \beta_{2}X^{2} + \beta_{3}X^{3} + \epsilon$

where $\beta_{0}$, $\beta_{1}$, $\beta_{2}$, and $\beta_{3}$ are contants of your choice. 

```{r}
beta_0 = 1.0
beta_1 = -0.1
beta_2 = +0.05
beta_3 = 0.75
```
```{r}
Y = beta_0 + beta_1 * X + beta_2 * X^2 + beta_3 * X^3 + epsilon
```

C. Use the `regsubsets()` function to perform best subset selection in order to choose the best model containing the predictors $X$, $X^{2}$,...,$X^{10}$. What is the best model obtained according to $C_{p}$, BIC, and adjusted $R^{2}$? Show some plots to provide evidence for your answer, and report the coefficients of the best model obtained. Note that you will need to use the `data.frame()` function to create a single dataset containing both X and Y. 

```{r}
DF = data.frame( Y=Y, X=X, X2=X^2, X3=X^3, X4=X^4, X5=X^5, X6=X^6, X7=X^7, X8=X^8, X9=X^9, X10=X^10 )
```

```{r}
# Use the validation approach with regsubsets 
train = sample(c(TRUE,FALSE), n, rep=TRUE) # will roughly assign TRUE to one-half of the data (FALSE to the other half).
test = (!train)
```

```{r}
# Apply best subset selection
regfit.full = regsubsets( Y ~ ., data=DF[train,], nvmax=10 )
print( summary( regfit.full ) )

reg.summary = summary( regfit.full )
```

```{r}
# Test models on the validation set
test.mat = model.matrix( Y ~ ., data=DF[test,] )
val.errors = rep(NA,10)
for( i in 1:10 ){
  coefi = coef( regfit.full, id=i )
  pred = test.mat[,names(coefi)] %*% coefi
  val.errors[i] = mean(( DF$Y[test] - pred )^2 ) 
}
print("best subset validation errors")
print(val.errors)
```

```{r}
k = which.min(val.errors)
print(k)
```

```{r}
print(coef(regfit.full, id=k))
```

```{r}
#old.par = par(mfrow=c(1,4))
plot(reg.summary$rss, xlab = "Number of Variables", ylab="RSS")
```
The best RSS model is one that uses 4 to 10 variables. 

```{r}
plot(reg.summary$cp, xlab = "Number of Variables", ylab="Cp", pch=19)
```

The best Cp model is one that uses 3 to 4 variables. 

```{r}
plot(reg.summary$bic, xlab = "Number of Variables", ylab="BIC", pch=19)
```

The best BIC model is one that uses 3 variables. 

```{r}
plot(reg.summary$adjr2, xlab = "Number of Variables", ylab="Adjusted R2", pch=19)
```

The best adjusted R2 model is one that uses 4 variables. 

```{r}
plot(val.errors, xlab = "Number of Variables", ylab = "Validation Errors", pch=19)
```

D. Repeat (C), using forward stepwise selection and also using backwards stepwise selection. How does your answer compare to the results in (C)?

```{r}
# Now apply forward selection on the training set 
regfit.forward = regsubsets(Y~., data=DF[train,], nvmax=10, method="forward")
print(summary(regfit.forward))
reg.summary = summary(regfit.forward)
```

```{r}
# Test models on the validation set 
test.mat = model.matrix( Y ~ ., data=DF[test,] )
val.errors = rep(NA,10)
for( i in 1:10 ){
  coefi = coef( regfit.forward, id=i )
  pred = test.mat[,names(coefi)] %*% coefi
  val.errors[i] = mean( ( DF$Y[test] - pred )^2 ) 
}
print( "forward selection validation errors" )
print( val.errors )
k = which.min( val.errors ) 
print( k )
print( coef( regfit.forward, id=k ) )
```

```{r}
plot( reg.summary$rss, xlab="Number of variables", ylab="RSS" )
```

The best RSS model is one that uses 6 to 10 variables. 

```{r}
plot( reg.summary$cp, xlab="Number of variables", ylab="Cp", pch=19 )
```
The best Cp model is one that uses 3 variables. 

```{r}
plot( reg.summary$bic, xlab="Number of variables", ylab="BIC", pch=19 )
```
The best BIC model is one that uses 3 variables. 

```{r}
plot( reg.summary$adjr2, xlab="Number of variables", ylab="adjusted R2", pch=19 )
```
The best adjusted R2 model is one that uses 4 variables. 

```{r}
plot( val.errors, xlab="Number of variables", ylab="Validation Errors", pch=19 )
```

```{r}
# Now apply backwards selection to the training set:
regfit.backward = regsubsets(Y~., data=DF[train,], nvmax=10, method="backward")
print(summary(regfit.backward))
reg.summary = summary(regfit.backward)
```

```{r}
# Test models on the validation set 
test.mat = model.matrix( Y ~ ., data=DF[test,] )
val.errors = rep(NA,10)
for( i in 1:10 ){
  coefi = coef( regfit.backward, id=i )
  pred = test.mat[,names(coefi)] %*% coefi
  val.errors[i] = mean( ( DF$Y[test] - pred )^2 ) 
}
print( "backwards selection validation errors" )
print( val.errors )
k = which.min( val.errors ) 
print( k )
print( coef( regfit.backward, id=k ) )
```

```{r}
plot( reg.summary$rss, xlab="Number of variables", ylab="RSS" )
```
The best RSS model is one that uses 4 to 10 variables. 

```{r}
plot( reg.summary$cp, xlab="Number of variables", ylab="Cp", pch=19 )
```
The best Cp model is one that uses 4 variables. 

```{r}
plot( reg.summary$bic, xlab="Number of variables", ylab="BIC", pch=19 )
```
The best BIC model is one that uses 4 variables. 

```{r}
plot( reg.summary$adjr2, xlab="Number of variables", ylab="adjusted R2", pch=19 )
```
The best adjusted R2 model is one that uses 4 variables. 

```{r}
plot( val.errors, xlab="Number of variables", ylab="Validation Errors", pch=19 )
```

E. Now fit a lasso model to the simulated data, again using $X$, $X^{2}$,...,$X_{10}$ as predictors. Use cross validation to select the optimal value of $\lambda$. Create plots of the cross validation errors as a function of $\lambda$. Report the resulting coefficient estimates, and discuss the results obtained. 

```{r}
# First fit the lasso model for all the given lambda values:
grid = 10^seq(10,-2, length=100) # Grid of lambda values
Y = DF$Y

MM = model.matrix(Y~., data=DF) # The predictors as a data matrix

lasso.mod = glmnet(MM, Y, alpha=1, lambda=grid)
plot(lasso.mod) # plot the extracted coefficients as a function of lambda
```

```{r}
# Apply cross validation to pick the best value of lambda 
cv.out = cv.glmnet(MM, Y, alpha=1)
bestlam = cv.out$lambda.1se
print("lasso CV best value of lambda (one standard error)")
print(bestlam)
```

```{r}
plot(cv.out)
```

```{r}
# Extract the optimal coefficients used:
lasso.coef = predict(lasso.mod, type="coefficients", s=bestlam)
print(lasso.coef)
```

F. Now generate a response vector Y according to the model:

$Y = \beta_{0} + \beta_{7}X^{7} + \epsilon$,

and perform best subset selection and the lasso. Discuss the results obtained. 

```{r}
# Try a different regression function: 
X = rnorm(n)
epsilon = 0.1*rnorm(n)
```

```{r}
beta_0 = 1.0
beta_7 = 2.5

Y = beta_0 + beta_7 * X^7 + epsilon

DF = data.frame( Y=Y, X=X, X2=X^2, X3=X^3, X4=X^4, X5=X^5, X6=X^6, X7=X^7, X8=X^8, X9=X^9, X10=X^10 )
```

```{r}
train = sample(c(TRUE,FALSE), n, rep=TRUE) # will roughly assign TRUE to one-half of the data (FALSE to the other half).
test = (!train)
```

```{r}
# Test best subset models on the validation set:
test.mat = model.matrix( Y ~ ., data=DF[test,] )
val.errors = rep(NA,10)
for( i in 1:10 ){
  coefi = coef( regfit.full, id=i )
  pred = test.mat[,names(coefi)] %*% coefi
  val.errors[i] = mean( ( DF$Y[test] - pred )^2 ) 
}
print( "best subsets validation errors" )
print( val.errors )
k = which.min( val.errors )
print( k ) 
print( "best subsets optimal coefficients" )
print( coef( regfit.full, id=k ) ) # print the coefficients of the best model 
print( val.errors[k] ) 
```

```{r}
# Using the lasso technique:
# First apply cross validation to find the optimal value of lambda:
MM = model.matrix(Y~., data=DF)

cv.out = cv.glmnet(MM, Y, alpha=1)
plot(cv.out)
```
```{r}
bestlam = cv.out$lambda.lse
print("best lambda (1 standard error)")
print(bestlam)
```

```{r}
# Now fit the lasso with this value of lambda:
lasso.mod = glmnet(MM, Y, alpha=1)
```

```{r}
lasso.coef = predict(lasso.mod, type="coefficients", s=bestlam)
print("lasso optimal coefficients")
print(lasso.coef)
```

```{r}
print("I do not think the predict method is working correcly...")
lasso.predict = predict(lasso.mod, s=bestlam, newx=MM)
print("Lasso MSE error")
print(mean((Y - lasso.predict)^2))
```

## Question Nine

In this exercise, we will predict the number of applications received using other variables in the `College` dataset. 

A. Split the dataset into a training set and a test set

```{r}
set.seed(0)

n = dim(College)[1]
p = dim(College)[2]
```

```{r}
train = sample(c(TRUE, FALSE), n, rep=TRUE) # Will roughly assign TRUE to one half of the dataset and FALSE to the other half 
test = (!train)
```

```{r}
College_train = College[train,]
College_test = College[test,]
```

B. Fit a linear model using least squares on the training set, and report the test error obtained. 

```{r}
m = lm(Apps~., data=College_train)

Y_hat = predict(m, newdata=College_test)
MSE = mean((College_test$Apps - Y_hat)^2)
print(sprintf("Linear model test MSE = %10.3f", MSE))
```

C. Fit a ridge regression model on the training set, with $\lambda$ chosen by cross-validation. Report the test error obtained. 

```{r}
Y = College_train$Apps
MM = model.matrix(Apps~., data=College_train)
cv.out = cv.glmnet(MM, Y, alpha=0)
plot(cv.out)
```
```{r}
bestlam = cv.out$lambda.1se
bestlam
```

```{r}
ridge.mod = glmnet(MM, Y, alpha=0)

Y_hat = predict(ridge.mod, s=bestlam, newx = model.matrix(Apps~., data=College_test))
MSE = mean((College_test$Apps - Y_hat)^2)
print(sprintf("Ridge regression test MSE = %10.3f", MSE))
```

D. Fit the lasso model on the training set, with $\lambda$ chosen by cross-validation. Report the test error obtained, along with the number of non-zero coefficient estimates. 

```{r}
cv.out = cv.glmnet(MM, Y, alpha=1)
plot(cv.out)
```
```{r}
bestlam = cv.out$lambda.1se
bestlam
```

```{r}
lasso.mod = glmnet(MM, Y, alpha=1)

Y_hat = predict(lasso.mod, s=bestlam, newx=model.matrix(Apps~., data=College_test))
MSE = mean((College_test$Apps - Y_hat)^2)
print(sprintf("Lasso regression test MSE = %10.3f", MSE))
print("lasso coefficients")
print(predict(lasso.mod, type="coefficients", s=bestlam))
```

E. Fit a PCR model on the training set, with M chosen by cross-validation. Report the test error obtained, along with the value of M selected by cross-validation. 

```{r}
pcr.mod = pcr(Apps~., data=College_train, scale=TRUE, validation="CV")

# Use this to select the number of components to include ... looks like CV suggests we should use all the predictors
validationplot(pcr.mod, val.type = "MSEP")
```
```{r}
ncomp = 17
Y_hat = predict(pcr.mod, College_test, ncomp=ncomp)
MSE = mean((College_test$Apps - Y_hat)^2)
print( sprintf( "PCR (with ncomp= %5d) test MSE= %10.3f", ncomp, MSE ) )
```

F. Fit a pLS model on the training set, with M chosen by cross-validation. Report the test error obtained, along with the value of M selected by cross-validation. 

```{r}
pls.mod = plsr(Apps~., data=College_train, scale=TRUE, validation="CV")

# Use this to select the number of components to include ... looks like CV suggests we should use ALL the predictors but there is not much change in moving from ~5 predictors to 17 so we will take 10 (somewhere in the middle)
validationplot(pls.mod, val.type = "MSEP")
```

```{r}
ncomp = 10
Y_hat = predict(pls.mod, College_test, ncomp=ncomp)
MSE = mean((College_test$Apps - Y_hat)^2)
print( sprintf( "PLS (with ncomp= %5d) test MSE= %10.3f", ncomp, MSE ) )
```

## Question Ten 

We have seen that as the number of features used in a model increases, the training error will necessarily decrease, but the test error may not. We will now explore this in a simulated dataset. 

A. Generate a dataset with p = 20 features, n = 1,000 observations, and an associated quanitative response vector generated according to the model:

$Y = X\beta + \epsilon$,

where $\beta$ has some elements that are exactly equal to zero. 

```{r}
set.seed(0)

# The sample size and the number of features:
n = 1000
p = 20
```

```{r}
# Create the true value of beta and zero out half of the entries:
beta_truth = rnorm(p + 1) # add one for the constant beta_0
zero_locations = c(2,3,4,7,8,11,12,15,17,20)
beta_truth[zero_locations] = 0

# For debugging lets check that we can recover our coefficients: 
#beta_truth = rep(0,p+1); beta_truth[1] = 1.5; beta_truth[10] = 3.5; beta_truth[15] = -3.4
print( "True values for beta (beta_0-beta_20):" )
print( beta_truth )
```

```{r}
# Generate some input features and an output response:
X = c(rep(1,n), rnorm(n*p)) # Make leading column of ones
X = matrix(X, nrow=n, ncol=(p+1), byrow=FALSE)

Y = X %*% beta_truth + rnorm(n)
```

```{r}
# Create a dataframe with this data:
DF = data.frame(Y, X[,-1]) # Drop the column of ones 
```

B. Split your dataset into a training set containing 100 observations and a test set containing 900 observations 

```{r}
train_inds = sample(1:n, 100)
test_inds = (1:n)[-train_inds]
```

C. Perform best subset selection on the training set, and plot the training set MSE associated with the best model of each size. 

```{r}
# Apply best subset selection using only the training data:
regfit.full = regsubsets(Y~., data=DF[train_inds,], nvmax=20)
reg.summary = summary(regfit.full)
```

```{r}
# Plot the in-sample MSE:
training.mat = model.matrix(Y~., data=DF[train_inds,])
training.errors = rep(NA,20)
for( i in 1:20 ){
  coefi = coef( regfit.full, id=i )
  pred = training.mat[,names(coefi)] %*% coefi
  training.errors[i] = mean( ( DF$Y[train_inds] - pred )^2 ) 
}
print( "best subset training MSE" )
print( training.errors )
```

```{r}
plot(1:20, training.errors, xlab = "Number of Predictors", ylab = "Training MSE", type="o", col="red", ylim=c(0,9))
```

D. Plot the test set MSE associated with the best model of each size. 

```{r}
plot(1:20, training.errors, xlab = "Number of Predictors", ylab = "Training MSE", type="o", col="red", ylim=c(0,9))

test.mat = model.matrix(Y~., data=DF[test_inds,])

val.errors = rep(NA,20)
for( i in 1:20 ){
  coefi = coef( regfit.full, id=i )
  pred = test.mat[,names(coefi)] %*% coefi
  val.errors[i] = mean( ( DF$Y[test_inds] - pred )^2 ) 
}
print( "best subset validation MSE" )
print( val.errors )
k = which.min( val.errors ) 
print( k )
print( coef( regfit.full, id=k ) )
points( 1:20, val.errors, xlab='number of predictors', ylab='testing MSE', type='o', col='green' )

grid()
legend(11, 9.25, c('Training MSE', 'Testing MSE'), col=c('red', 'green'), lty = c(1,1))
```

G. Create a plot displaying $\sqrt{\sum_{j=1}^{p}(\beta_{j} - \hat{\beta^{r}_{j}})^{2}}$ for a range of values of r, where $\hat{\beta^{r}_{j}}$ is the jth coefficient estimate for the best model containing r coefficients. Comment on what you observe. How does this compare to the test MSE plot from (D)?

```{r}
nms = colnames(DF)
nms[1] = "(Intercept)"
names(beta_truth) = nms
```

```{r}
norm.beta.diff = rep(NA,20)
for( i in 1:20 ){
  coefi = coef( regfit.full, id=i )
  norm.beta.diff[i] = sqrt( sum( ( beta_truth[ names( coefi ) ] - coefi )^2 ) ) 
}
```

```{r}
plot(1:20, norm.beta.diff, xlab="Number of Predictors", ylab="||beta_truth = beta^r||", type="o", col="green")
grid()
```

## Question Eleven 

We will now try to predict per capital crime rate in the `Boston` dataset. 

A. Try out some regression methods, such as best subset selection, the lasso, ridge regression and PCR. Present and discuss results for the approaches that you consider. 

```{r eval=FALSE, include=FALSE}
set.seed(0)

n = dim(Boston)[1]
p = dim(Boston)[2]

train = sample(c(TRUE, FALSE), n, rep=TRUE) # Will roughly assign TRUE to one-half of the data and FALSE to the other half
test = (!train)

Boston_train = Boston[train,]
Boston_test = Boston[test,]
```

```{r eval=FALSE, include=FALSE}
# The full linear model:
m = lm(crim~., data=Boston_train)

Y_hat = predict(m, newdata=Boston_test)
MSE = mean((Boston_test$crim - Y_hat)^2)
print(sprintf("Linear model test MSE = %10.3f", MSE))
```

```{r eval=FALSE, include=FALSE}
# Ridge Regression:
Y = Boston_train$crim
MM = model.matrix(crim~., data=Boston_train)
cv.out = cv.glmnet(MM, Y, alpha=0)
plot(cv.out)
```
```{r eval=FALSE, include=FALSE}
bestlam = cv.out$lambda.1se
#print( "ridge regression CV best value of lambda (one standard error)" )
#print( bestlam )
```

```{r eval=FALSE, include=FALSE}
ridge.mod = glmnet(MM, Y, alpha=0)

Y_hat = predict(ridge.mod, s=bestlam, newx=model.matrix(crim~., data=Boston_test))
MSE = mean((Boston_test$crim - Y_hat)^2)
print(sprintf("Ridge regression test MSE = %10.3f", MSE))
```

```{r eval=FALSE, include=FALSE}
# The Lasso: 

cv.out = cv.glmnet(MM, Y, alpha=1)
plot(cv.out)
```
```{r eval=FALSE, include=FALSE}
bestlam = cv.out$lambda.1se
#print( "lasso CV best value of lambda (one standard error)" )
#print( bestlam )
```

```{r eval=FALSE, include=FALSE}
lasso.mod = glmnet(MM, Y, alpha=1)

Y_hat = predict(lasso.mod, s=bestlam, newx=model.matrix(crim~., data=Boston_test))
MSE = mean((Boston_test$crim - Y_hat)^2)
print(sprintf("Lasso regression test MSE = %10.3f", MSE))
print("lasso coefficients")
print(predict(lasso.mod, type="coefficients", s=bestlam))

```

```{r eval=FALSE, include=FALSE}
# Principal Component Regression:

pcr.mod = pcr(crim ~., data=Boston_train, scale=TRUE, validation="CV")

# Use this to select the number of components to include ... looks like CV suggests we should use 3 predictors
validationplot(pcr.mod, val.type = "MSEP")
```

```{r eval=FALSE, include=FALSE}
ncomp=3
Y_hat = predict(pcr.mod, Boston_test, ncomp = ncomp)
MSE = mean((Boston_test$crim - Y_hat)^2)
print(sprintf("PCR (with ncomp = %5d), test MSE = %10.3f", ncomp, MSE))
```

```{r eval=FALSE, include=FALSE}
# Partial Least Squares:
pls.mod = plsr(crim~., data=Boston_train, scale=TRUE, validation="CV")

# Use this to select the number of components to include ... looks like CV suggests the best is to use 5 predictors 
validationplot(pls.mod, val.type="MSEP")
```
```{r eval=FALSE, include=FALSE}
ncomp = 5
Y_hat = predict(pls.mod, Boston_test, ncomp=ncomp)
MSE = mean((Boston_test$crim - Y_hat)^2)
print(sprintf("PLS (with ncomp = %5d) test MSE = %10.3f", ncomp, MSE))
```

